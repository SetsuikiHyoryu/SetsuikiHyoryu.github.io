import{_ as l,c as e,o,a3 as i}from"./chunks/framework.Cbi_dvob.js";const z=JSON.parse('{"title":"Neovim 0.10 内置折叠命令","description":"","frontmatter":{},"headers":[],"relativePath":"zh/programming/coding-memo/neovim-fold-commands.md","filePath":"zh/programming/coding-memo/neovim-fold-commands.md","lastUpdated":1723810684000}'),a={name:"zh/programming/coding-memo/neovim-fold-commands.md"},d=i('<h1 id="neovim-0-10-内置折叠命令" tabindex="-1">Neovim 0.10 内置折叠命令 <a class="header-anchor" href="#neovim-0-10-内置折叠命令" aria-label="Permalink to &quot;Neovim 0.10 内置折叠命令&quot;">​</a></h1><ul><li>官方文档：<a href="https://neovim.io/doc/user/fold.html#fold-commands" target="_blank" rel="noreferrer">https://neovim.io/doc/user/fold.html#fold-commands</a></li><li>需要 <code>foldmethod</code> 为 &quot;manual&quot; 或 &quot;marker&quot;（默认值是 &quot;manual&quot;）。</li></ul><h2 id="创建折叠" tabindex="-1">创建折叠 <a class="header-anchor" href="#创建折叠" aria-label="Permalink to &quot;创建折叠&quot;">​</a></h2><p>并非必须在一个定义域符号内（比如括号），完全无关的两行也能折叠。</p><ul><li><code>zf{motion}</code> / <code>{Visual}zf</code></li><li><code>{count}zF</code></li><li><code>:{range}fo[ld]</code></li></ul><h2 id="删除折叠" tabindex="-1">删除折叠 <a class="header-anchor" href="#删除折叠" aria-label="Permalink to &quot;删除折叠&quot;">​</a></h2><ul><li>zd： <ul><li>删除光标处的折叠。</li><li>有嵌套时，删除外层折叠，内层折叠将上浮一个等级。</li><li>光标在内层折叠处执行删除，则不影响外层。</li><li>有删除比预期更多的折叠的风险。</li></ul></li><li>zD: 递归地删除光标处的所有折叠。</li><li>zE: 删除当前窗口中的所有折叠。</li></ul><h2 id="开关折叠" tabindex="-1">开关折叠 <a class="header-anchor" href="#开关折叠" aria-label="Permalink to &quot;开关折叠&quot;">​</a></h2><ul><li>小于 <code>foldminlines</code> 所设置的行（默认值是 1）将始终显示。</li><li>关闭折叠将设置 <code>foldenable</code>。</li><li><code>foldenable</code> <code>fen</code>: 当值为 off 时，所有折叠将被打开，默认值为 on。</li></ul><hr><ul><li>za: 开关光标处的折叠。</li><li>zA: 递归地开关光标处的所有折叠。</li></ul><h3 id="关闭折叠" tabindex="-1">关闭折叠 <a class="header-anchor" href="#关闭折叠" aria-label="Permalink to &quot;关闭折叠&quot;">​</a></h3><ul><li>zc: <ul><li>关闭光标处的折叠。</li><li>有嵌套时，仅关闭光标所在处最内层的折叠。</li></ul></li><li>zC: 递归地关闭光标处的所有折叠。</li><li><code>:{range}foldc[lose][!]</code>: <ul><li>关闭 <code>{range}</code> 范围内一个等级的折叠。</li><li>如果使用 <code>!</code>，则关闭范围内的所有折叠。</li></ul></li></ul><h3 id="打开折叠" tabindex="-1">打开折叠 <a class="header-anchor" href="#打开折叠" aria-label="Permalink to &quot;打开折叠&quot;">​</a></h3><ul><li>zo: 打开光标处的折叠。</li><li>zO: 递归地打开光标处的所有折叠。</li><li>zv: 一直打开折叠直到光标处能显示。</li><li><code>:{range}foldo[pen][!]</code>: <ul><li>打开 <code>{range}</code> 范围内一个等级的折叠。</li><li>如果使用 <code>!</code>，则打开范围内的所有折叠。</li></ul></li><li>zn: 重置 <code>foldenable</code>，打开所有折叠。</li><li>zN: 设置 <code>foldenable</code>，所有折叠恢复到原来的状态。</li><li>zi: 倒置 <code>foldenable</code>。</li></ul><h3 id="不熟练" tabindex="-1">不熟练 <a class="header-anchor" href="#不熟练" aria-label="Permalink to &quot;不熟练&quot;">​</a></h3><ul><li>zx: 撤销手动打开或关闭的折叠。</li><li>zX: 递归地撤销手动打开或关闭的折叠。</li><li>zm: 从 <code>foldlevel</code> 减去 <code>v:count1</code>。</li><li>zM: 关闭所有折叠，并将 <code>foldlevel</code> 设为 0。</li><li>zr: 将 <code>v:count1</code> 加入 <code>foldlevel</code>。</li><li>zR: 打开所有折叠，设置 <code>foldlevel</code> 为最高等级。</li></ul><h2 id="在折叠处移动" tabindex="-1">在折叠处移动 <a class="header-anchor" href="#在折叠处移动" aria-label="Permalink to &quot;在折叠处移动&quot;">​</a></h2><ul><li><code>[z</code>: 移动到折叠的开始处。</li><li><code>]z</code>: 移动到折叠的结束处。</li><li>zj: 移动到下一个折叠的开始处。</li><li>zk: 移动到上一个折叠的关闭处。</li></ul>',19),c=[d];function n(t,r,m,u,h,s){return o(),e("div",null,c)}const _=l(a,[["render",n]]);export{z as __pageData,_ as default};
